# DE1-project - I2C communication

## Documentation
This project implements an FPGA-based I2C communication system for reading temperature data from the ADT7420 and a display interface for real-time temperature visualization on a 7-segment display.

<p align="center">
  <img src="img/TOP_LEVEL.png">
</p>

![osc](img/scope_funkcni.png)

### Clock gen
The clock_gen module generates a clock signal at a specified frequency by dividing a 100 MHz input clock. It outputs a signal that toggles at a 50% duty cycle, effectively producing a square wave at the desired frequency. This output is used as a timing signal (e.g., 400 kHz or 1 Hz) for other modules requiring a slower clock domain.

This block uses a synchronous counter to toggle the output clock enable signal, and it does not have an external reset.
![obrazek](https://github.com/user-attachments/assets/a21dc6ec-d4ab-461e-a6ac-ef1ee7049a47)
![obrazek](https://github.com/user-attachments/assets/d9391c38-287d-4947-aad5-8336646387ec)

### Seg drive
The seg drive module is a synchronous module used to dislplay meassured temperature using 7 out of 8 availiable 7-segment display units with non floating decimal point. Module is able to display values in range +-99.9999. 

Input value is represented by integer value that contains actual value multiplied by 10^4 (e.g., 256365 for 25.6365). Module mathematically separates digits of input number and displays them on individual units using upgraded 7-segment driver from classes with 400 kHz refresh rate.
<p align="center">
  <img src="/img/SEG_DRIVE.png" width="400">
  <img src="/img/Segment_simulation.png">
</p>


### ADT7420 driver
This module works closely with I2C driver. Specific informations about temperature sensor ADT7420 including I2C address, register value and state-machine necessary for optaining desired information is stored in this module. 

1. `start` signal is used to progress from `WAIT_FOR_START_STATE`. Edges of both clock signal and start signal could be shifted from each other depending on frequency of start signal. For that very reason `latch_start` signal is used to actually start the state-machine.
1. Module commands starts of the I2C transaction by passing necessary informations to underlying I2C driver. 
1. Module waits until I2C driver reports that commanded operation has ended either successfully (`done = '1'`) or not (`bit_error = '1'`). After unsuccesful request state-machine falls back into `WAIT_FOR_START_STATE` state.
1. After successful request module converts returnted response into temperature. Programm does not implement FPU so the convertend temperature is stored as fixed point decimal number in 10E4 degrees Celsius. Simple check of converted temperature is performed to isolate ironious values. Before falling back into `WAIT_FOR_START_STATE` `done_read <= '1'` is written for I2C driver to signal that response was read and it too can fall back into idle state.

<p align="center">
  <img src="img/ADT7420_flow_chart.png" width="400">
  <img src="img/ADT7420_simulation.png">
</p>

### I2C driver
I2C driver establishes communication between ADT7420 driver and the sensor itself. The code is separated into 3 processes which are sensitive to clock signal generated by clock_gen module:
- rising_process is sensitive to rising edge of the clock signal and responsible for switching between states (FSM), reading data from both slave and master, and increasing iterative signals such as counter or read_counter.
- falling_process on the other hand based on conditional statements and iterative signals changes SDA_drive and SCL_drive signals between '0' a 'Z' ('Z' stands for released bus).
- If a signal disable_auto_SCL is set to '0' p_SCL_driver updates the SCL_drive according to the signal from clock_gen, otherwise SCL is set to 'Z'.
- Collaterally to these processes inouts SDA and SCL are updated from signals SCL_drive and SDA_drive.
The correct sequence of the FSM is stored in the array 'state_sequence'.

#### Successfull communication
1. `Reset` is set to be always the first state in the FSM. 'Reset' state generally lasts untill the push button on the Nexys_a7_50T is not being pushed anymore so the `rst` is low.
2. I2C_driver is in `Idle` state untill receiving any data from ADT7420_driver, which is tested by condition `num_bytes /= '0'`.
3. 'Start_condition' is defined as  high-to-low transition on 'SDA' while `SCL` remains high. Note that only in start/stop condition SDA doesnt change on falling edge.
4. `Send_address_w` is processed in both rising and falling processes. In rising_process on rising edges there is an internal signal `counter` that increases every clock period. On the other hand in falling_process we utilize the increasing 'counter' for indexing an appropriate bit in the 'address' 7-bit input vector. There is also a convertor for converting logic '1' to released bus `Z`. `w` in the name of this state stands for write bit ('0') which is the last bit in the 8-bit frame. 
5. After sending address there is a state `Check_ack`, which detects whether the sensor send acknowledge ('0') or not ('Z'). If the sensor didnt send the ack, signal `error_signal` is set to '1' and the next state is `stop`, otherwise its `Send_register`.
6. Note that for `Send_register` is used the same logic as for the `Send_address_w` state except the reg input vector is 8-bit and we dont deal with that last bit must be set to '0'.
7. Next follows `Check_ack` state again and then `Start` - no differences.
8. `Send_address_r` is the same as with the `w` except `r` as a read bit stands for `Z`. Last `Check_ack` follows.
9. As `Check_ack` state `Read_data` is only in rising_process, because we need to read the data on rising_edge. At first the `read_size` variable is set according to signals `num_bytes` and `read_counter`. `read_size` represents the length of the response vector - 1 (at the beginning it should be 15 or 7). 'H' in the logic convertor means weak-pull-up.
10.  
![obrazek](img/I2C_simulation_part1.png)
#### Nack from ADT7420

![obrazek](img/I2C_simulation_part2.png)
#### Flowchart
![obrazek](img/I2C_driver_flowchart_light.drawio.png)


